# AnagramCount

Этот файл содержит решение второй задачи о подсчете анаграм в строке. 

При парном программировании онлайн было сделано переборное решение  
сложности N^4 (в четвертой степени). Ниже решение, которое показывает квадратичную зависимость от длины входной строки. В решении выведена сложность решения - теорерически обяснено, почему она квадратичная.
Также квадратичная сложность решения подтверждается тестами. К решению приложен график с результатами запусков.
При запуске решение выводит данные, полностью подтверждающиме квадратичную зависимость.

Ниже привожу график зависимости и график вывода программы:

![График зависимости](Doc/graph_anagram.png)
![Результат работы программы](Doc/anagram_statistics.png)

## Описание алгоритма
Шерлок и Анаграммы
<br>Две строки являются анаграммами друг друга, если буквы одной строки можно переставить, чтобы 
получить другую строку. Дана строка, найдите количество пар подстрок этой строки, которые 
являются анаграммами друг друга.

<br>Описание алгоритма:

<br>Два слова являются анаграммами друг друга, если одно слово может быть получено из другого путем смены порядка символов. Реверс слово является лишь частным случаем анаграммы.
<br>Очевидно, что у всех анаграмм одного и того же слова является неизменной одна характеристика: набор символов, встречаемых в анаграмме и количество встречаемости каждого символа в анаграмме. Это своего рода детерминант анаграммы. Понятно, что если мы отсортируем все символы в анаграмме по возрастанию, мы тоже получим детерминант анаграммы.
<br>В этой программе для получения детерминанта анаграммы мы будем использовать сортировку.
Две строки являются анаграммами друг друга, если результаты сортировки каждой из них равны.

<br>Алгоритм:

```
Объявляем целое число anogramSum = 0;

Внешний цикл: идем по длине подстроки len = от 1 до (длина входной строки -1).
{
    Создаем ассоциативный массив map<string, long>.
    в этом массиве мы будем накапливать анаграммы и сколько раз они встретились в исходной строке.
    
    Первый вложенный цикл: 
    мы берем последовательные подстроки входной строки длиной переменной len из внешнего цикла
    {

        Каждую такую подстроку мы сортирует во возрастанию по символа - получаем детерминант строки.
        И увеличиваем значение map[детерминант]++;

        цель - подсчитать прямое количество, сколько раз анаграммы встречаются в строке
    }
    
    Второй вложенный цикл.
    Идем по всем элементам ассоциативного массива map (по всем анаграммам)
    {
        Расчитываем количество пар для текущей арангаммы.
        У нас есть общее количество встречаемости анаграммы N.
        Количество пар: (N-1)+(N-2)+ ... +1

        (1 + (N-1))
        ----------- (N-1) = N*(N-1)
             2

        Это арифметическая прогрессия, сумма которой = N*(N-1)/2
        При операциях приводить к дробному и округлять не надо, т.к. сумма целых всегда целая.
        А также потому, что из двух последовательных чисел (N-1) и N четное. 

        anogramSum += КоличествоПар
    }
}

вернуть anogramSum 
```


## Оценка сложности алгоритма
Внутри алгоритма есть внешний цикл и два вложенных цикла. Оценка сложности N^2.
Я сделал вывод количества операций, количества анаграм и длины строки.
Строки для оценки сложности формировались случайным образом из алфавита a-z.
На графике видна парабола y=ax^2+bx-59. Коэффициенты я рассчитал исходя из реальных данных, которые вернула программа: парабола задается тремя точками. Я взял данные в точках 
[50], [100], [150], решил систему из трех линейных уравнений и получил коэффициенты.
Как видно на графике, парабола точно наложилась на график: видно, что синие штрихи идут поверх рыжих.  

## Автотесты
Решение содержит тесты, где введены все примеры входных данных и ожидаемые результаты работы программы, которые совпали. Все тесты автоматически запускаются при запуске программы. 

<br>ОПЫТНЫМ ПУТЕМ ВЫЯСНИЛ, ЧТО ЭТО РЕШЕНИЕ ДАЕТ КВАДРАТИЧНУЮ ЗАВИСИМОСТЬ ОТ КОЛИЧЕСТВА ДАННЫХ.
<br>ЦЕЛЬ ДОСТИГНУТА ПОЛНОСТЬЮ!!!

